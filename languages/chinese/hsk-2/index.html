<!doctype html>
<html lang="en">
<head>
  <title>HSK 2.0 Vocabulary · Chinese · Memogatary</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.png" type="image/png" />
  <link rel="stylesheet" href="/assets/css/styles.css" />
  <script type="module" src="/assets/js/components/header.js"></script>
  <script type="module" src="/assets/js/components/footer.js"></script>
  <!-- Tailwind for layout helpers -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #pdf-viewer canvas {
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
    }
    #pdf-nav button:disabled { opacity:.5; cursor:not-allowed; }
  </style>
</head>

<body>
  <site-header></site-header>

  <main class="container prose">
    <h1>HSK 2.0 Vocabulary</h1>

    <!-- Viewer controls -->
    <div class="max-w-5xl mx-auto my-6">
      <label class="block text-sm text-slate-600 mb-1">Choose material</label>
      <select id="pdf-select" class="w-full border rounded p-2"></select>
      <p id="list-status" class="text-xs text-slate-500 mt-1"></p>
    </div>

    <!-- Jump to page -->
    <div class="flex gap-2 items-end my-4">
      <div>
        <label class="block text-sm text-slate-600 mb-1">Go to page</label>
        <input id="goto-input" type="number" min="1" class="border rounded p-2 w-28" />
      </div>
      <button id="goto-btn" class="h-10 px-4 rounded bg-indigo-600 text-white">Go</button>
    </div>

    <!-- PDF Viewer -->
    <section id="pdf-viewer" class="mt-4">
      <p id="loading-message" class="text-slate-600">Loading…</p>

      <!-- Spinner + label -->
      <div id="busy" class="hidden mt-3 flex items-center gap-2 text-slate-600">
        <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" class="opacity-25"></circle>
          <path d="M4 12a8 8 0 018-8" fill="currentColor" class="opacity-75"></path>
        </svg>
        <span id="busy-label">Preparing…</span>
      </div>

      <!-- Progress bar -->
      <div id="dl-progress" class="hidden mt-3">
        <div class="w-full bg-gray-200 rounded">
          <div id="dl-bar" class="h-2 rounded bg-indigo-600" style="width:0%"></div>
        </div>
        <div id="dl-label" class="text-xs text-slate-600 mt-1">0%</div>
      </div>

      <div id="pdf-render-area" class="hidden justify-center items-start gap-4 p-2 bg-white rounded-t-lg shadow">
        <canvas id="pdf-canvas-1"></canvas>
        <canvas id="pdf-canvas-2"></canvas>
      </div>
      <div id="pdf-nav" class="hidden flex gap-3 justify-between items-center p-2 border-t bg-gray-50 rounded-b-lg">
        <div class="flex gap-2">
          <button id="prev-page" class="bg-gray-300 text-gray-900 font-semibold py-2 px-4 rounded">&lt; Previous</button>
          <button id="next-page" class="bg-gray-300 text-gray-900 font-semibold py-2 px-4 rounded">Next &gt;</button>
        </div>
        <span id="page-num-display" class="text-slate-700 font-medium"></span>
      </div>
    </section>
  </main>

  <site-footer></site-footer>

  <!-- PDF.js -->
  <script>
    /***** CONFIG *****/
    const APPS_SCRIPT_BASE = 'https://script.google.com/macros/s/AKfycbyNrsxztUHt0T5NY6eaQkM6F9p5KKPrAZDIFUFq03mSUxqWK6LFY6xaATvP_25EpFT_6Q/exec';
    const FOLDER_ID = '1fxVRg5zDlf-Zre6uy8ac48C3ILHtaPfF';
    const VERSION = 'v2'; // bump to bust caches after updates

    // ~50MB Apps Script response ceiling; keep a buffer for headers/base64 overhead (~+33%)
    const MAX_SAFE_BASE64 = 47 * 1024 * 1024;

    /* ---- State & refs ---- */
    let pdfDoc = null;
    let currentPage = 1;
    let twoPageMode = true;            // desktop=2 pages, mobile=1
    const cache = new Map();           // fileId -> base64 string
    const fileSizes = new Map();       // fileId -> sizeBytes

    const $ = (id) => document.getElementById(id);
    const canvas1 = () => $('pdf-canvas-1');
    const canvas2 = () => $('pdf-canvas-2');
    const ctx1 = () => canvas1().getContext('2d');
    const ctx2 = () => canvas2().getContext('2d');

    function setStatus(msg){ const el=$('list-status'); if(el) el.textContent = msg; }
    function setLoading(msg){ const el=$('loading-message'); if(el) el.textContent = msg; }

    function showBusy(show, label){
      const box = $('busy'), txt = $('busy-label');
      if(!box) return;
      if(typeof label === 'string' && txt) txt.textContent = label;
      box.classList.toggle('hidden', !show);
    }
    function showProgress(show){
      const box = $('dl-progress'); if(box) box.classList.toggle('hidden', !show);
    }
    function setProgress(pct, text){
      const bar = $('dl-bar'), lbl = $('dl-label');
      if(bar) bar.style.width = Math.max(0, Math.min(100, pct)) + '%';
      if(lbl) lbl.textContent = text ?? (Math.round(pct) + '%');
    }
    function estimateBase64Length(byteLen){ return 4 * Math.ceil(byteLen / 3); }

    function setModeFromViewport(){
      twoPageMode = !window.matchMedia('(max-width: 768px)').matches;
      canvas2().style.display = twoPageMode ? 'block' : 'none';
    }

    /* ---- Base64 decoder (hardened) ---- */
    function safeDecodeBase64ToBytes(b64){
      const head = (b64 || '').slice(0, 200);

      if (!b64) throw new Error('Empty response from server.');

      if (head.startsWith('ERROR:')) {
        throw new Error(head); // Plain-text error returned by Apps Script
      }
      if (head.startsWith('<')) {
        throw new Error('Server returned HTML (Apps Script error). First bytes: ' + head);
      }
      if (head.startsWith('{')) {
        throw new Error('Server returned JSON (error object). First bytes: ' + head);
      }

      // Strip whitespace/newlines and pad
      b64 = b64.replace(/[\r\n\s]+/g, '');
      while (b64.length % 4 !== 0) b64 += '=';

      if (!/^[A-Za-z0-9+/=]+$/.test(b64)) {
        throw new Error('Invalid base64 characters. First bytes: ' + head);
      }

      let binary = '';
      try { binary = atob(b64); }
      catch (e) { throw new Error('atob failed: ' + e.message + '. First bytes: ' + head); }

      const len = binary.length;
      const out = new Uint8Array(len);
      for (let i = 0; i < len; i++) out[i] = binary.charCodeAt(i);
      return out;
    }

    /* ---- Networking ---- */
    async function fetchList(){
      const url = `${APPS_SCRIPT_BASE}?mode=list&folderId=${encodeURIComponent(FOLDER_ID)}&v=${VERSION}`;
      let res, text;
      try {
        res = await fetch(url, { cache: 'no-store' });
        text = await res.text();
      } catch (e) {
        setStatus(`Network error: ${e.message}`);
        throw e;
      }
      if (!res.ok) {
        setStatus(`HTTP ${res.status}: ${text.slice(0,200)}`);
        throw new Error(`HTTP ${res.status}`);
      }
      const data = JSON.parse(text);
      if (data?.error) {
        setStatus(`Script error: ${data.error}`);
        throw new Error(data.error);
      }
      return data; // [{id,name,display,modifiedTime,sizeBytes}, ...]
    }

    async function getPdfBase64(fileId){
      if (cache.has(fileId)) return cache.get(fileId);

      // Guard: avoid oversized base64 payloads
      const expectedBinary = fileSizes.get(fileId) || 0;
      const expectedBase64 = expectedBinary ? estimateBase64Length(expectedBinary) : 0;
      if (expectedBase64 > MAX_SAFE_BASE64) {
        const mb = (expectedBinary / (1024*1024)).toFixed(1);
        throw new Error(`This PDF is too large for Apps Script base64 (${mb} MB). Please compress/split.`);
      }

      const url = `${APPS_SCRIPT_BASE}?mode=get&fileId=${encodeURIComponent(fileId)}&v=${VERSION}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`PDF fetch failed (HTTP ${res.status})`);

      // PREPARING (server reading & encoding) – no client progress possible yet
      showBusy(true, 'Preparing…');
      showProgress(false);

      // When bytes start arriving, switch UI to “Downloading…”
      const reader = res.body.getReader();
      const chunks = [];
      let received = 0, started = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        if (!started) {
          started = true;
          showBusy(false);
          showProgress(true);
          setProgress(1, 'Downloading… 1%');
        }

        chunks.push(value);
        received += value.length;

        if (expectedBase64 > 0) {
          const pct = Math.min(99, Math.floor((received / expectedBase64) * 100));
          setProgress(pct, `Downloading… ${pct}%`);
        } else {
          setProgress(0, `Downloading… ${Math.round(received / 1024)} KB`);
        }
      }

      const blob = new Blob(chunks);
      const b64 = await blob.text();

      showProgress(false);
      showBusy(true, 'Processing…');

      cache.set(fileId, b64);
      return b64;
    }

    /* ---- Rendering ---- */
    async function loadAndOpen(fileId){
      setLoading('Loading PDF...');
      showBusy(true, 'Preparing…');

      const { pdfjsLib } = window;
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

      let b64;
      try {
        b64 = await getPdfBase64(fileId);
      } catch (e) {
        showBusy(false); showProgress(false);
        setStatus('Fetch error: ' + e.message);
        console.error('Fetch error:', e);
        return;
      }

      let data;
      try {
        data = safeDecodeBase64ToBytes(b64);
      } catch (e) {
        showBusy(false); showProgress(false);
        setStatus('Decode error: ' + e.message);
        console.error('Decode failure. Length:', (b64||'').length, 'Head:', (b64||'').slice(0,200));
        return;
      }

      showBusy(true, 'Processing…');
      try {
        pdfDoc = await pdfjsLib.getDocument({ data }).promise;
      } catch (e) {
        showBusy(false);
        setStatus('PDF parse error: ' + e.message);
        console.error('PDF.js parse error:', e);
        return;
      }

      $('loading-message').style.display = 'none';
      $('pdf-render-area').style.display = 'flex';
      $('pdf-nav').style.display = 'flex';

      currentPage = 1;
      showBusy(true, 'Rendering…');
      await renderPages(currentPage);
      updateNavButtons();

      showBusy(false);
    }

    async function renderPages(startPage){
      if (!pdfDoc) return;
      startPage = Math.max(1, Math.min(startPage, pdfDoc.numPages));

      const renderArea = $('pdf-render-area');
      const style = window.getComputedStyle(renderArea);
      const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      const gap = parseFloat(style.gap) || 0;
      let availableWidth = renderArea.clientWidth - paddingX;

      const page1 = await pdfDoc.getPage(startPage);
      let totalPdfWidth = page1.getViewport({ scale: 1 }).width;

      let page2 = null, page2Num = null;
      if (twoPageMode) {
        page2Num = startPage + 1;
        if (page2Num <= pdfDoc.numPages) {
          availableWidth -= gap;
          page2 = await pdfDoc.getPage(page2Num);
          totalPdfWidth += page2.getViewport({ scale: 1 }).width;
        }
      }

      const scale = availableWidth / totalPdfWidth;

      const vp1 = page1.getViewport({ scale });
      canvas1().width = vp1.width; canvas1().height = vp1.height;
      await page1.render({ canvasContext: ctx1(), viewport: vp1 }).promise;
      canvas1().style.display = 'block';

      if (twoPageMode && page2) {
        const vp2 = page2.getViewport({ scale });
        canvas2().width = vp2.width; canvas2().height = vp2.height;
        await page2.render({ canvasContext: ctx2(), viewport: vp2 }).promise;
        canvas2().style.display = 'block';
        $('page-num-display').textContent = `Pages ${startPage}–${page2Num} of ${pdfDoc.numPages}`;
      } else {
        canvas2().style.display = 'none';
        $('page-num-display').textContent = `Page ${startPage} of ${pdfDoc.numPages}`;
      }

      currentPage = startPage;
    }

    function updateNavButtons(){
      const prevDisabled = currentPage <= 1;
      const nextDisabled = twoPageMode
        ? (currentPage + 1 >= pdfDoc.numPages)
        : (currentPage >= pdfDoc.numPages);
      $('prev-page').disabled = prevDisabled;
      $('next-page').disabled = nextDisabled;
    }

    function populateSelect(items){
      const sel = $('pdf-select');
      sel.innerHTML = '';
      fileSizes.clear();

      // Natural-ish sort
      items.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'}));

      items.forEach(it=>{
        fileSizes.set(it.id, Number(it.sizeBytes || 0));
        const opt = document.createElement('option');
        opt.value = it.id;
        opt.textContent = it.display || it.name.replace(/\.pdf$/i,'');
        sel.appendChild(opt);
      });
    }

    /* ---- Init & events ---- */
    async function initHSK(){
      setModeFromViewport();
      window.addEventListener('resize', async ()=>{
        setModeFromViewport();
        if (pdfDoc) {
          if (twoPageMode && currentPage % 2 === 0) currentPage -= 1; // keep spread alignment
          await renderPages(currentPage);
          updateNavButtons();
        }
      });

      setStatus('Loading materials...');
      try {
        const list = await fetchList();
        if (!list.length) { setStatus('No PDFs found.'); return; }
        populateSelect(list);
        setStatus(`${list.length} materials found.`);
        $('pdf-select').addEventListener('change', (e)=> loadAndOpen(e.target.value));
        await loadAndOpen(list[0].id);
      } catch (err) {
        setStatus(`Failed: ${err.message}`);
      }

      $('prev-page').addEventListener('click', async ()=>{
        const delta = twoPageMode ? 2 : 1;
        const target = currentPage - delta;
        if (target >= 1) {
          await renderPages(target);
          updateNavButtons();
        }
      });

      $('next-page').addEventListener('click', async ()=>{
        const delta = twoPageMode ? 2 : 1;
        const target = currentPage + delta;
        if (target <= pdfDoc.numPages) {
          await renderPages(target);
          updateNavButtons();
        }
      });

      $('goto-btn').addEventListener('click', async ()=>{
        if (!pdfDoc) return;
        const val = parseInt($('goto-input').value, 10);
        if (isNaN(val)) return;
        let target = Math.max(1, Math.min(val, pdfDoc.numPages));
        if (twoPageMode && target % 2 === 0) target -= 1; // left page on spread
        await renderPages(target);
        updateNavButtons();
      });
    }

    // Load PDF.js then init
    (function loadPdfJs(){
      const s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js';
      s.onload = initHSK;
      s.onerror = () => setStatus('Failed to load PDF.js');
      document.head.appendChild(s);
    })();
  </script>
</body>
</html>
