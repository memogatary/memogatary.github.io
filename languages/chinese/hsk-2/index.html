<!doctype html>
<html lang="en">
<head>
  <title>HSK 2.0 Vocabulary · Chinese · Memogatary</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.png" type="image/png" />
  <link rel="stylesheet" href="/assets/css/styles.css" />
  <script type="module" src="/assets/js/components/header.js"></script>
  <script type="module" src="/assets/js/components/footer.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #pdf-viewer canvas {
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
    }
    #pdf-nav button:disabled { opacity:.5; cursor:not-allowed; }
  </style>
</head>

<body>
  <site-header></site-header>

  <main class="container prose">
    <h1>HSK 2.0 Vocabulary</h1>

    <!-- File picker -->
    <div class="max-w-5xl mx-auto my-6">
      <label class="block text-sm text-slate-600 mb-1">Choose material</label>
      <select id="pdf-select" class="w-full border rounded p-2"></select>
      <p id="list-status" class="text-xs text-slate-500 mt-1"></p>
    </div>

    <!-- Jump to page -->
    <div class="flex gap-2 items-end my-4">
      <div>
        <label class="block text-sm text-slate-600 mb-1">Go to page</label>
        <input id="goto-input" type="number" min="1" class="border rounded p-2 w-28" />
      </div>
      <button id="goto-btn" class="h-10 px-4 rounded bg-indigo-600 text-white">Go</button>
    </div>

    <!-- PDF Viewer -->
    <section id="pdf-viewer" class="mt-4">
      <p id="loading-message" class="text-slate-600">Loading…</p>

      <!-- Spinner -->
      <div id="busy" class="hidden mt-3 flex items-center gap-2 text-slate-600">
        <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" class="opacity-25"></circle>
          <path d="M4 12a8 8 0 018-8" fill="currentColor" class="opacity-75"></path>
        </svg>
        <span id="busy-label">Preparing…</span>
      </div>

      <!-- Progress -->
      <div id="dl-progress" class="hidden mt-3">
        <div class="w-full bg-gray-200 rounded">
          <div id="dl-bar" class="h-2 rounded bg-indigo-600" style="width:0%"></div>
        </div>
        <div id="dl-label" class="text-xs text-slate-600 mt-1">0%</</div>
      </div>

      <div id="pdf-render-area" class="hidden justify-center items-start gap-4 p-2 bg-white rounded-t-lg shadow">
        <canvas id="pdf-canvas-1"></canvas>
        <canvas id="pdf-canvas-2"></canvas>
      </div>
      <div id="pdf-nav" class="hidden flex gap-3 justify-between items-center p-2 border-t bg-gray-50 rounded-b-lg">
        <div class="flex gap-2">
          <button id="prev-page" class="bg-gray-300 text-gray-900 font-semibold py-2 px-4 rounded">&lt; Previous</button>
          <button id="next-page" class="bg-gray-300 text-gray-900 font-semibold py-2 px-4 rounded">Next &gt;</button>
        </div>
        <span id="page-num-display" class="text-slate-700 font-medium"></span>
      </div>
    </section>
  </main>

  <site-footer></site-footer>

  <script>
    /***** CONFIG *****/
    const APPS_SCRIPT_BASE = 'https://script.google.com/macros/s/AKfycbwoogQ5ds_Qvqmcb_giKDyQXe6y05XIlXFfak4EjzRLTm8budQVRFGRKTsFKM8VAnWf/exec';
    const FOLDER_ID = '1fxVRg5zDlf-Zre6uy8ac48C3ILHtaPfF';
    const VERSION = 'v3'; // cache-buster for list/chunk requests

    /* ---- State & refs ---- */
    let pdfDoc = null;
    let currentPage = 1;
    let twoPageMode = true;            // desktop=2 pages, mobile=1
    const $ = (id) => document.getElementById(id);

    const canvas1 = () => $('pdf-canvas-1');
    const canvas2 = () => $('pdf-canvas-2');
    const ctx1 = () => canvas1().getContext('2d');
    const ctx2 = () => canvas2().getContext('2d');

    const fileSizes = new Map();       // fileId -> sizeBytes

    /* ---- UI helpers ---- */
    function setStatus(msg){ const el=$('list-status'); if(el) el.textContent = msg; }
    function setLoading(msg){ const el=$('loading-message'); if(el) el.textContent = msg; }

    function showBusy(show, label){
      const box = $('busy'), txt = $('busy-label');
      if(!box) return;
      if(typeof label === 'string' && txt) txt.textContent = label;
      box.classList.toggle('hidden', !show);
    }
    function showProgress(show){
      const box = $('dl-progress'); if(box) box.classList.toggle('hidden', !show);
    }
    function setProgress(pct, text){
      const bar = $('dl-bar'), lbl = $('dl-label');
      if(bar) bar.style.width = Math.max(0, Math.min(100, pct)) + '%';
      if(lbl) lbl.textContent = text ?? (Math.round(pct) + '%');
    }
    function setModeFromViewport(){
      twoPageMode = !window.matchMedia('(max-width: 768px)').matches;
      canvas2().style.display = twoPageMode ? 'block' : 'none';
    }

    /* ---- Networking: list ---- */
    async function fetchList(){
      const url = `${APPS_SCRIPT_BASE}?mode=list&folderId=${encodeURIComponent(FOLDER_ID)}&v=${VERSION}`;
      const res = await fetch(url, { cache: 'no-store' });
      const text = await res.text();
      if (!res.ok) { setStatus(`HTTP ${res.status}: ${text.slice(0,200)}`); throw new Error(`HTTP ${res.status}`); }
      const data = JSON.parse(text);
      if (data?.error) { setStatus(`Script error: ${data.error}`); throw new Error(data.error); }
      return data; // [{id,name,display,modifiedTime,sizeBytes}, ...]
    }

    /* ---- Chunked download helpers ---- */

    // Strict base64->bytes for each chunk
    function b64ToBytes(b64) {
      b64 = (b64 || '').replace(/[\r\n\s]+/g, '');
      while (b64.length % 4 !== 0) b64 += '=';
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i=0; i<bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    // Query file info (size/version)
    async function getInfo(fileId) {
      const url = `${APPS_SCRIPT_BASE}?mode=getInfo&fileId=${encodeURIComponent(fileId)}&v=${VERSION}`;
      const res = await fetch(url, { cache: 'no-store' });
      const text = await res.text();
      if (!res.ok) throw new Error(`Info HTTP ${res.status}: ${text.slice(0,200)}`);
      const data = JSON.parse(text);
      if (data?.error) throw new Error(data.error);
      return data; // {sizeBytes, version}
    }

    // Download in base64 chunks and stitch into a single Uint8Array
    async function getPdfBytesChunked(fileId, chunkSize = 1024 * 1024) { // 1 MB chunks
      const info = await getInfo(fileId);
      const total = Number(info.sizeBytes || 0);
      if (!total) throw new Error('Server did not report file size.');

      showBusy(false);
      showProgress(true);
      setProgress(1, 'Downloading… 1%');

      let offset = 0;
      const chunks = [];
      while (offset < total) {
        const url = `${APPS_SCRIPT_BASE}?mode=getChunk&fileId=${encodeURIComponent(fileId)}&offset=${offset}&length=${chunkSize}&v=${VERSION}`;
        const res = await fetch(url, { cache: 'no-store' });
        const txt = await res.text();
        if (!res.ok) throw new Error(`Chunk HTTP ${res.status}: ${txt.slice(0,200)}`);

        let payload;
        try { payload = JSON.parse(txt); }
        catch { throw new Error('Bad JSON from chunk endpoint: ' + txt.slice(0,200)); }

        if (payload.error) throw new Error(payload.error);
        if (!payload.ok || typeof payload.offset !== 'number' || !payload.chunkB64) {
          throw new Error('Malformed chunk response: ' + txt.slice(0,200));
        }

        const bytes = b64ToBytes(payload.chunkB64);
        chunks.push(bytes);

        offset = payload.end;
        const pct = Math.min(99, Math.floor((offset / total) * 100));
        setProgress(pct, `Downloading… ${pct}%`);
      }

      showProgress(false);
      showBusy(true, 'Processing…');

      // Concatenate
      let totalLen = 0;
      for (const c of chunks) totalLen += c.length;
      const out = new Uint8Array(totalLen);
      let pos = 0;
      for (const c of chunks) { out.set(c, pos); pos += c.length; }
      return out;
    }

    /* ---- Rendering ---- */
    async function loadAndOpen(fileId){
      setLoading('Loading PDF...');
      showBusy(true, 'Preparing…');

      // Load PDF.js worker
      const { pdfjsLib } = window;
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

      let data;
      try {
        // Chunked download to bytes
        data = await getPdfBytesChunked(fileId);
      } catch (e) {
        showBusy(false); showProgress(false);
        setStatus('Download error: ' + e.message);
        console.error(e);
        return;
      }

      showBusy(true, 'Processing…');
      try {
        pdfDoc = await pdfjsLib.getDocument({ data }).promise;
      } catch (e) {
        showBusy(false);
        setStatus('PDF parse error: ' + e.message);
        console.error('PDF.js parse error:', e);
        return;
      }

      $('loading-message').style.display = 'none';
      $('pdf-render-area').style.display = 'flex';
      $('pdf-nav').style.display = 'flex';

      currentPage = 1;
      showBusy(true, 'Rendering…');
      await renderPages(currentPage);
      updateNavButtons();
      showBusy(false);
    }

    async function renderPages(startPage){
      if (!pdfDoc) return;
      startPage = Math.max(1, Math.min(startPage, pdfDoc.numPages));

      const renderArea = $('pdf-render-area');
      const style = window.getComputedStyle(renderArea);
      const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      const gap = parseFloat(style.gap) || 0;
      let availableWidth = renderArea.clientWidth - paddingX;

      const page1 = await pdfDoc.getPage(startPage);
      let totalPdfWidth = page1.getViewport({ scale: 1 }).width;

      let page2 = null, page2Num = null;
      if (twoPageMode) {
        page2Num = startPage + 1;
        if (page2Num <= pdfDoc.numPages) {
          availableWidth -= gap;
          page2 = await pdfDoc.getPage(page2Num);
          totalPdfWidth += page2.getViewport({ scale: 1 }).width;
        }
      }

      const scale = availableWidth / totalPdfWidth;

      const vp1 = page1.getViewport({ scale });
      canvas1().width = vp1.width; canvas1().height = vp1.height;
      await page1.render({ canvasContext: ctx1(), viewport: vp1 }).promise;
      canvas1().style.display = 'block';

      if (twoPageMode && page2) {
        const vp2 = page2.getViewport({ scale });
        canvas2().width = vp2.width; canvas2().height = vp2.height;
        await page2.render({ canvasContext: ctx2(), viewport: vp2 }).promise;
        canvas2().style.display = 'block';
        $('page-num-display').textContent = `Pages ${startPage}–${page2Num} of ${pdfDoc.numPages}`;
      } else {
        canvas2().style.display = 'none';
        $('page-num-display').textContent = `Page ${startPage} of ${pdfDoc.numPages}`;
      }

      currentPage = startPage;
    }

    function updateNavButtons(){
      const prevDisabled = currentPage <= 1;
      const nextDisabled = twoPageMode
        ? (currentPage + 1 >= pdfDoc.numPages)
        : (currentPage >= pdfDoc.numPages);
      $('prev-page').disabled = prevDisabled;
      $('next-page').disabled = nextDisabled;
    }

    function populateSelect(items){
      const sel = $('pdf-select');
      sel.innerHTML = '';
      fileSizes.clear();

      // Natural-ish sort
      items.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'}));
      items.forEach(it=>{
        fileSizes.set(it.id, Number(it.sizeBytes || 0));
        const opt = document.createElement('option');
        opt.value = it.id;
        opt.textContent = it.display || it.name.replace(/\.pdf$/i,'');
        sel.appendChild(opt);
      });
    }

    /* ---- Init & events ---- */
    async function initHSK(){
      setModeFromViewport();
      window.addEventListener('resize', async ()=>{
        setModeFromViewport();
        if (pdfDoc) {
          if (twoPageMode && currentPage % 2 === 0) currentPage -= 1; // keep spread alignment
          await renderPages(currentPage);
          updateNavButtons();
        }
      });

      setStatus('Loading materials...');
      try {
        const list = await fetchList();
        if (!list.length) { setStatus('No PDFs found.'); return; }
        populateSelect(list);
        setStatus(`${list.length} materials found.`);
        $('pdf-select').addEventListener('change', (e)=> loadAndOpen(e.target.value));
        await loadAndOpen(list[0].id);
      } catch (err) {
        setStatus(`Failed: ${err.message}`);
      }

      $('prev-page').addEventListener('click', async ()=>{
        const delta = twoPageMode ? 2 : 1;
        const target = currentPage - delta;
        if (target >= 1) {
          await renderPages(target);
          updateNavButtons();
        }
      });

      $('next-page').addEventListener('click', async ()=>{
        const delta = twoPageMode ? 2 : 1;
        const target = currentPage + delta;
        if (target <= pdfDoc.numPages) {
          await renderPages(target);
          updateNavButtons();
        }
      });

      $('goto-btn').addEventListener('click', async ()=>{
        if (!pdfDoc) return;
        const val = parseInt($('goto-input').value, 10);
        if (isNaN(val)) return;
        let target = Math.max(1, Math.min(val, pdfDoc.numPages));
        if (twoPageMode && target % 2 === 0) target -= 1; // left page on spread
        await renderPages(target);
        updateNavButtons();
      });
    }

    // Load PDF.js then init
    (function loadPdfJs(){
      const s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js';
      s.onload = initHSK;
      s.onerror = () => setStatus('Failed to load PDF.js');
      document.head.appendChild(s);
    })();
  </script>
</body>
</html>
