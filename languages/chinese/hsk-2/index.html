<!doctype html>
<html lang="en">
<head>
  <title>HSK 2.0 Vocabulary · Chinese · Memogatary</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.png" type="image/png" />
  <link rel="stylesheet" href="/assets/css/styles.css" />
  <script type="module" src="/assets/js/components/header.js"></script>
  <script type="module" src="/assets/js/components/footer.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Fixed-height viewer window with its own scrollbar */
    #viewer-viewport {
      height: 78vh;              /* tweak to taste (e.g., 70–85vh) */
      overflow: auto;
      border: 1px solid #e5e7eb; /* gray-200 */
      border-radius: 0.5rem;
      background: #fff;
    }
    #pdf-viewer canvas { max-width: 100%; height: auto; border: 1px solid #ddd; }
    #pdf-nav button:disabled { opacity:.5; cursor:not-allowed; }
  </style>
</head>

<body>
  <site-header></site-header>

  <main class="container prose">
    <h1>HSK 2.0 Vocabulary</h1>

    <!-- File picker -->
    <div class="max-w-5xl mx-auto my-6">
      <label class="block text-sm text-slate-600 mb-1">Choose material</label>
      <select id="pdf-select" class="w-full border rounded p-2"></select>
      <p id="list-status" class="text-xs text-slate-500 mt-1"></p>
    </div>

    <!-- View mode (default: Scroll) -->
    <div class="flex items-end gap-3 my-4">
      <div>
        <label class="block text-sm text-slate-600 mb-1">View</label>
        <select id="view-mode" class="border rounded p-2">
          <option value="scroll" selected>Continuous scroll (viewport)</option>
          <option value="spread">Paginated (1–2 pages)</option>
        </select>
      </div>

      <!-- Jump to page (only for paginated) -->
      <div id="goto-wrap" class="flex items-end gap-2 hidden">
        <div>
          <label class="block text-sm text-slate-600 mb-1">Go to page</label>
          <input id="goto-input" type="number" min="1" class="border rounded p-2 w-28" />
        </div>
        <button id="goto-btn" class="h-10 px-4 rounded bg-indigo-600 text-white">Go</button>
      </div>
    </div>

    <!-- Shared loading/status UI -->
    <section id="pdf-viewer" class="mt-2">
      <p id="loading-message" class="text-slate-600">Loading…</p>

      <!-- Spinner -->
      <div id="busy" class="hidden mt-3 flex items-center gap-2 text-slate-600">
        <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" class="opacity-25"></circle>
          <path d="M4 12a8 8 0 018-8" fill="currentColor" class="opacity-75"></path>
        </svg>
        <span id="busy-label">Preparing…</span>
      </div>

      <!-- Progress -->
      <div id="dl-progress" class="hidden mt-3">
        <div class="w-full bg-gray-200 rounded">
          <div id="dl-bar" class="h-2 rounded bg-indigo-600" style="width:0%"></div>
        </div>
        <div id="dl-label" class="text-xs text-slate-600 mt-1">0%</div>
      </div>

      <!-- Fixed-height viewport -->
      <div id="viewer-viewport" class="mt-3 p-2">
        <!-- PAGINATED VIEW (inside viewport) -->
        <div id="pdf-render-area" class="hidden justify-center items-start gap-4 p-2 bg-white rounded-t-lg">
          <canvas id="pdf-canvas-1"></canvas>
          <canvas id="pdf-canvas-2"></canvas>
        </div>
        <div id="pdf-nav" class="hidden flex gap-3 justify-between items-center p-2 border-t bg-gray-50 rounded-b-lg">
          <div class="flex gap-2">
            <button id="prev-page" class="bg-gray-300 text-gray-900 font-semibold py-2 px-4 rounded">&lt; Previous</button>
            <button id="next-page" class="bg-gray-300 text-gray-900 font-semibold py-2 px-4 rounded">Next &gt;</button>
          </div>
          <span id="page-num-display" class="text-slate-700 font-medium"></span>
        </div>

        <!-- SCROLL VIEW (grid inside viewport) -->
        <section id="pdf-scroll" class="mt-1">
          <div id="scroll-grid" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
        </section>
      </div>
    </section>
  </main>

  <site-footer></site-footer>

  <script>
    /***** CONFIG *****/
    const APPS_SCRIPT_BASE = 'https://script.google.com/macros/s/AKfycbwoogQ5ds_Qvqmcb_giKDyQXe6y05XIlXFfak4EjzRLTm8budQVRFGRKTsFKM8VAnWf/exec';
    const FOLDER_ID = '1fxVRg5zDlf-Zre6uy8ac48C3ILHtaPfF';
    const VERSION = 'v7'; // cache-buster

    /* ---- State & refs ---- */
    let pdfDoc = null;
    let currentPage = 1;
    let twoPageMode = true;
    let viewMode = 'scroll';      // default: scroll
    let scrollObserver = null;    // IntersectionObserver for scroll mode
    let pdfjsWorkerSet = false;

    const $ = (id) => document.getElementById(id);
    const viewportEl = () => document.getElementById('viewer-viewport');

    const canvas1 = () => $('pdf-canvas-1');
    const canvas2 = () => $('pdf-canvas-2');

    /* ---- UI helpers ---- */
    function setStatus(msg){ const el=$('list-status'); if(el) el.textContent = msg; }
    function setLoading(msg){ const el=$('loading-message'); if(el) el.textContent = msg; }
    function showBusy(show, label){
      const box = $('busy'), txt = $('busy-label');
      if(!box) return;
      if(typeof label === 'string' && txt) txt.textContent = label;
      box.classList.toggle('hidden', !show);
    }
    function showProgress(show){
      const box = $('dl-progress'); if(box) box.classList.toggle('hidden', !show);
    }
    function setProgress(pct, text){
      const bar = $('dl-bar'), lbl = $('dl-label');
      if(bar) bar.style.width = Math.max(0, Math.min(100, pct)) + '%';
      if(lbl) lbl.textContent = text ?? (Math.round(pct) + '%');
    }
    function setModeFromViewport(){
      twoPageMode = !window.matchMedia('(max-width: 768px)').matches;
      canvas2().style.display = twoPageMode ? 'block' : 'none';
    }

    /* ---- Networking: list & chunks ---- */
    async function fetchList(){
      const url = `${APPS_SCRIPT_BASE}?mode=list&folderId=${encodeURIComponent(FOLDER_ID)}&v=${VERSION}`;
      const res = await fetch(url, { cache: 'no-store' });
      const text = await res.text();
      if (!res.ok) { setStatus(`HTTP ${res.status}: ${text.slice(0,200)}`); throw new Error(`HTTP ${res.status}`); }
      const data = JSON.parse(text);
      if (data?.error) { setStatus(`Script error: ${data.error}`); throw new Error(data.error); }
      return data;
    }
    function b64ToBytes(b64) {
      b64 = (b64 || '').replace(/[\r\n\s]+/g, '');
      while (b64.length % 4 !== 0) b64 += '=';
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i=0; i<bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }
    async function getInfo(fileId) {
      const url = `${APPS_SCRIPT_BASE}?mode=getInfo&fileId=${encodeURIComponent(fileId)}&v=${VERSION}`;
      const res = await fetch(url, { cache: 'no-store' });
      const text = await res.text();
      if (!res.ok) throw new Error(`Info HTTP ${res.status}: ${text.slice(0,200)}`);
      const data = JSON.parse(text);
      if (data?.error) throw new Error(data.error);
      return data;
    }
    async function getPdfBytesChunked(fileId, chunkSize = 1024 * 1024) {
      const info = await getInfo(fileId);
      const total = Number(info.sizeBytes || 0);
      if (!total) throw new Error('Server did not report file size.');
      showBusy(false); showProgress(true); setProgress(1, 'Downloading… 1%');

      let offset = 0, chunks = [];
      while (offset < total) {
        const url = `${APPS_SCRIPT_BASE}?mode=getChunk&fileId=${encodeURIComponent(fileId)}&offset=${offset}&length=${chunkSize}&v=${VERSION}`;
        const res = await fetch(url, { cache: 'no-store' });
        const txt = await res.text();
        if (!res.ok) throw new Error(`Chunk HTTP ${res.status}: ${txt.slice(0,200)}`);
        const payload = JSON.parse(txt);
        if (payload.error || !payload.ok || !payload.chunkB64) throw new Error(payload.error || 'Malformed chunk');
        chunks.push(b64ToBytes(payload.chunkB64));
        offset = payload.end;
        const pct = Math.min(99, Math.floor((offset / total) * 100));
        setProgress(pct, `Downloading… ${pct}%`);
      }
      showProgress(false); showBusy(true, 'Processing…');

      let totalLen = 0; for (const c of chunks) totalLen += c.length;
      const out = new Uint8Array(totalLen);
      let pos = 0; for (const c of chunks) { out.set(c, pos); pos += c.length; }
      // quick %PDF check
      const sig = [0x25,0x50,0x44,0x46]; let ok=false;
      for (let i=0;i<Math.min(64,out.length-3);i++){ if(out[i]===sig[0]&&out[i+1]===sig[1]&&out[i+2]===sig[2]&&out[i+3]===sig[3]){ok=true;break;}}
      if(!ok) throw new Error('Downloaded bytes do not look like a PDF.');
      return out;
    }

    /* ---- Rendering: Paginated ---- */
    async function loadAndOpen(fileId){
      setLoading('Loading PDF...'); showBusy(true, 'Preparing…');
      const { pdfjsLib } = window;
      if (!pdfjsLib) { setStatus('PDF.js not loaded.'); showBusy(false); return; }
      if (!pdfjsWorkerSet){
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
        pdfjsWorkerSet = true;
      }

      let data;
      try { data = await getPdfBytesChunked(fileId); }
      catch (e) { showBusy(false); showProgress(false); setStatus('Download error: ' + e.message); return; }

      showBusy(true, 'Processing…');
      try { pdfDoc = await pdfjsLib.getDocument({ data }).promise; }
      catch (e) { showBusy(false); setStatus('PDF parse error: ' + e.message); return; }

      $('loading-message').style.display = 'none';

      // Switch to the currently selected view mode
      if (viewMode === 'scroll') {
        enterScrollMode();
      } else {
        enterPaginatedMode();
      }
      showBusy(false);
    }

    async function renderPages(startPage){
      if (!pdfDoc) return;
      startPage = Math.max(1, Math.min(startPage, pdfDoc.numPages));

      const renderArea = $('pdf-render-area');
      const style = window.getComputedStyle(renderArea);
      const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      const gap = parseFloat(style.gap) || 0;
      let availableWidth = renderArea.clientWidth - paddingX;

      const page1 = await pdfDoc.getPage(startPage);
      let totalPdfWidth = page1.getViewport({ scale: 1 }).width;

      let page2 = null, page2Num = null;
      if (twoPageMode) {
        page2Num = startPage + 1;
        if (page2Num <= pdfDoc.numPages) {
          availableWidth -= gap;
          page2 = await pdfDoc.getPage(page2Num);
          totalPdfWidth += page2.getViewport({ scale: 1 }).width;
        }
      }

      const scale = availableWidth / totalPdfWidth;

      const vp1 = page1.getViewport({ scale });
      const c1 = canvas1();
      c1.width = vp1.width; c1.height = vp1.height;
      await page1.render({ canvasContext: c1.getContext('2d'), viewport: vp1 }).promise;
      c1.style.display = 'block';

      if (twoPageMode && page2) {
        const vp2 = page2.getViewport({ scale });
        const c2 = canvas2();
        c2.width = vp2.width; c2.height = vp2.height;
        await page2.render({ canvasContext: c2.getContext('2d'), viewport: vp2 }).promise;
        c2.style.display = 'block';
        $('page-num-display').textContent = `Pages ${startPage}–${page2Num} of ${pdfDoc.numPages}`;
      } else {
        canvas2().style.display = 'none';
        $('page-num-display').textContent = `Page ${startPage} of ${pdfDoc.numPages}`;
      }

      currentPage = startPage;
    }
    function updateNavButtons(){
      const prevDisabled = currentPage <= 1;
      const nextDisabled = twoPageMode
        ? (currentPage + 1 >= pdfDoc.numPages)
        : (currentPage >= pdfDoc.numPages);
      $('prev-page').disabled = prevDisabled;
      $('next-page').disabled = nextDisabled;
    }

    function enterPaginatedMode(){
      // hide scroll view
      $('pdf-scroll').classList.add('hidden');
      if (scrollObserver){ scrollObserver.disconnect(); scrollObserver = null; }
      $('scroll-grid').innerHTML = '';

      // show paginated widgets inside the viewport
      $('goto-wrap').classList.remove('hidden');
      $('pdf-render-area').style.display = 'flex';
      $('pdf-nav').style.display = 'flex';

      currentPage = 1;
      showBusy(true, 'Rendering…');
      renderPages(currentPage).then(()=>updateNavButtons()).finally(()=>showBusy(false));
    }

    /* ---- Rendering: Scroll (continuous, in fixed viewport) ---- */
    function enterScrollMode(){
      // hide paginated widgets
      $('pdf-render-area').style.display = 'none';
      $('pdf-nav').style.display = 'none';
      $('goto-wrap').classList.add('hidden');

      // show scroll grid
      $('pdf-scroll').classList.remove('hidden');
      const grid = $('scroll-grid');
      grid.innerHTML = '';

      // Create placeholders (one canvas per page)
      for(let i=1;i<=pdfDoc.numPages;i++){
        const wrap = document.createElement('div');     // grid cell
        wrap.className = 'flex justify-center';
        const canvas = document.createElement('canvas');
        canvas.dataset.page = String(i);
        canvas.width = 10; canvas.height = 10;          // placeholder
        wrap.appendChild(canvas);
        grid.appendChild(wrap);
      }

      // Lazy render with IntersectionObserver rooted to the viewport
      const rootEl = viewportEl();
      scrollObserver = new IntersectionObserver(async (entries)=>{
        for (const entry of entries){
          if (!entry.isIntersecting) continue;
          const canvas = entry.target;
          if (canvas.dataset.rendered === '1') continue;

          const pageNum = parseInt(canvas.dataset.page, 10);
          const page = await pdfDoc.getPage(pageNum);

          // Fit to the width of its grid cell
          const cell = canvas.parentElement;
          const cellWidth = cell.clientWidth; // already 1 or 1/2 of grid width
          const natural = page.getViewport({ scale: 1 }).width;
          const scale = Math.max(0.1, (cellWidth - 2) / natural); // small padding
          const vp = page.getViewport({ scale });

          canvas.width = vp.width; canvas.height = vp.height;
          await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
          canvas.dataset.rendered = '1';
        }
      }, { root: rootEl, rootMargin: '200px 0px', threshold: 0.01 });

      // Observe all canvases
      grid.querySelectorAll('canvas').forEach(c => scrollObserver.observe(c));

      // Re-render visible pages on viewport resize (e.g., when grid switches to 1↔2 cols)
      let resizeTimer = null;
      const onResize = ()=>{
        if (viewMode !== 'scroll') return;
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(async ()=>{
          const gridEl = $('scroll-grid');
          const canvases = Array.from(gridEl.querySelectorAll('canvas'));
          const vh = rootEl.clientHeight;
          const vr = rootEl.getBoundingClientRect();

          // only re-render canvases that are near the viewport
          for (const canvas of canvases){
            const r = canvas.getBoundingClientRect();
            const visible = (r.bottom > vr.top - 200) && (r.top < vr.top + vh + 200);
            if (!visible) continue;

            const pageNum = parseInt(canvas.dataset.page, 10);
            const page = await pdfDoc.getPage(pageNum);
            const cell = canvas.parentElement;
            const cellWidth = cell.clientWidth;
            const natural = page.getViewport({ scale: 1 }).width;
            const scale = Math.max(0.1, (cellWidth - 2) / natural);
            const vp = page.getViewport({ scale });
            canvas.width = vp.width; canvas.height = vp.height;
            await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
            canvas.dataset.rendered = '1';
          }
        }, 150);
      };

      // listen to window resize + viewport scroll
      window.addEventListener('resize', onResize, { passive:true });
      rootEl.addEventListener('scroll', onResize, { passive:true });
    }

    /* ---- Init & events ---- */
    function populateSelect(items){
      const sel = $('pdf-select'); sel.innerHTML = '';
      items.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'}));
      items.forEach(it=>{
        const opt = document.createElement('option');
        opt.value = it.id;
        opt.textContent = it.display || it.name.replace(/\.pdf$/i,'');
        sel.appendChild(opt);
      });
    }

    async function initHSK(){
      setModeFromViewport();
      // When viewport width changes, refresh paginated scales
      window.addEventListener('resize', async ()=>{
        setModeFromViewport();
        if (viewMode==='spread' && pdfDoc) {
          if (twoPageMode && currentPage % 2 === 0) currentPage -= 1;
          await renderPages(currentPage); updateNavButtons();
        }
      });

      // view mode toggle
      $('view-mode').addEventListener('change', async (e)=>{
        viewMode = e.target.value;
        if (!pdfDoc) return;
        if (viewMode === 'scroll') enterScrollMode();
        else enterPaginatedMode();
      });

      setStatus('Loading materials...');
      try {
        const list = await fetchList();
        if (!list.length) { setStatus('No PDFs found.'); return; }
        populateSelect(list);
        setStatus(`${list.length} materials found.`);
        $('pdf-select').addEventListener('change', (e)=> loadAndOpen(e.target.value));
        await loadAndOpen(list[0].id);     // loads default PDF in **scroll** view
      } catch (err) {
        setStatus(`Failed: ${err.message}`);
      }

      // Paginated navigation
      $('prev-page').addEventListener('click', async ()=>{
        if (!pdfDoc || viewMode!=='spread') return;
        const delta = twoPageMode ? 2 : 1;
        const target = currentPage - delta;
        if (target >= 1) { await renderPages(target); updateNavButtons(); }
      });
      $('next-page').addEventListener('click', async ()=>{
        if (!pdfDoc || viewMode!=='spread') return;
        const delta = twoPageMode ? 2 : 1;
        const target = currentPage + delta;
        if (target <= pdfDoc.numPages) { await renderPages(target); updateNavButtons(); }
      });
      $('goto-btn').addEventListener('click', async ()=>{
        if (!pdfDoc || viewMode!=='spread') return;
        const val = parseInt($('goto-input').value, 10);
        if (isNaN(val)) return;
        let target = Math.max(1, Math.min(val, pdfDoc.numPages));
        if (twoPageMode && target % 2 === 0) target -= 1;
        await renderPages(target); updateNavButtons();
      });
    }

    // Load PDF.js then init
    (function loadPdfJs(){
      const s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js';
      s.onload = initHSK;
      s.onerror = () => setStatus('Failed to load PDF.js');
      document.head.appendChild(s);
    })();
  </script>
</body>
</html>
